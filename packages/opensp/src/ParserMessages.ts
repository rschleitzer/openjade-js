// Copyright (c) 1994 James Clark
// See the file COPYING for copying permission.

// Parser message types
// This is a stub implementation for now - full message definitions would come from ParserMessages.msg

import { MessageType0, MessageType1, MessageType2, MessageType3, MessageType } from './Message';

export const pass2Ee = new MessageType0(MessageType.Severity.error, null, -1, 'pass 2 error');
export const peroGrpoProlog = new MessageType0(MessageType.Severity.error, null, -1, 'a name group is not allowed in a parameter entity reference in the prolog');
export const noSuchDeclarationType = new MessageType1(MessageType.Severity.error, null, -1, 'unknown declaration type %1');
export const dtdSubsetDeclaration = new MessageType1(MessageType.Severity.error, null, -1, '%1 declaration not allowed in DTD subset');
export const declSubsetCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'character %1 not allowed in declaration subset');
export const documentEndDtdSubset = new MessageType0(MessageType.Severity.error, null, -1, 'end of document in DTD subset');
export const specialParseEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in character data, replaceable character data or ignored marked section');
export const dataMarkedSectionDeclSubset = new MessageType0(MessageType.Severity.error, null, -1, 'data or replaceable character data in declaration subset');
export const documentEndLpdSubset = new MessageType0(MessageType.Severity.error, null, -1, 'end of document in LPD subset');
export const lpdSubsetDeclaration = new MessageType1(MessageType.Severity.error, null, -1, '%1 declaration not allowed in LPD subset');
export const activeDocLink = new MessageType0(MessageType.Severity.error, null, -1, 'active document link');
export const sorryActiveDoctypes = new MessageType0(MessageType.Severity.error, null, -1, 'sorry, multiple active doctypes not supported');
export const linkActivateTooLate = new MessageType0(MessageType.Severity.warning, null, -1, 'link type activation too late');
export const defaultEntityInAttribute = new MessageType1(MessageType.Severity.warning, null, -1, 'default entity reference in attribute: %1');
export const unstableLpdParameterEntity = new MessageType1(MessageType.Severity.error, null, -1, 'unstable LPD parameter entity: %1');
export const unstableLpdGeneralEntity = new MessageType1(MessageType.Severity.error, null, -1, 'unstable LPD general entity: %1');
export const concurrentInstances = new MessageType1(MessageType.Severity.error, null, -1, 'too many concurrent instances: %1');
export const giveUp = new MessageType0(MessageType.Severity.error, null, -1, 'cannot continue because of previous errors');
export const subdocGiveUp = new MessageType0(MessageType.Severity.error, null, -1, 'cannot continue with subdocument because of previous errors');
export const subdocLevel = new MessageType1(MessageType.Severity.error, null, -1, 'number of open subdocuments exceeds quantity specified for SUBDOC parameter in SGML declaration (%1)');
export const numberLength = new MessageType1(MessageType.Severity.error, null, -1, 'number token exceeds NAMELEN limit (%1)');
export const nameTokenLength = new MessageType1(MessageType.Severity.error, null, -1, 'name token exceeds NAMELEN limit (%1)');
export const nonSgmlCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'non-SGML character number %1');
export const nameLength = new MessageType1(MessageType.Severity.error, null, -1, 'name exceeds NAMELEN limit (%1)');
export const endTagCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'invalid character in end tag: %1');
export const endTagEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in end tag');
export const unclosedEndTagShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'unclosed end tag (shorttag feature required)');
export const endTagInvalidToken = new MessageType1(MessageType.Severity.error, null, -1, 'invalid token in end tag: %1');
export const emptyEndTag = new MessageType0(MessageType.Severity.warning, null, -1, 'empty end tag');
export const emptyStartTag = new MessageType0(MessageType.Severity.warning, null, -1, 'empty start tag');
export const emptyEndTagNoOpenElements = new MessageType0(MessageType.Severity.error, null, -1, 'empty end tag with no open elements');
export const emptyEndTagBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'empty end tag not in base DTD');
export const emptyStartTagBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'empty start tag not in base DTD');
export const elementNotFinished = new MessageType1(MessageType.Severity.error, null, -1, 'element %1 not finished');
export const elementEndTagNotFinished = new MessageType1(MessageType.Severity.error, null, -1, 'end tag for element %1 which is not finished');
export const taglen = new MessageType1(MessageType.Severity.error, null, -1, 'length of start tag exceeds TAGLEN limit (%1)');
export const noCurrentRank = new MessageType1(MessageType.Severity.error, null, -1, 'no current rank for %1');
export const startTagMissingName = new MessageType0(MessageType.Severity.error, null, -1, 'missing name in start tag');
export const endTagMissingName = new MessageType0(MessageType.Severity.error, null, -1, 'missing name in end tag');
export const startTagGroupNet = new MessageType0(MessageType.Severity.error, null, -1, 'NET delimiter in group start tag');
export const processingInstructionEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in processing instruction');
export const processingInstructionLength = new MessageType1(MessageType.Severity.error, null, -1, 'processing instruction length exceeds PILEN limit (%1)');
export const processingInstructionClose = new MessageType0(MessageType.Severity.error, null, -1, 'missing processing instruction close');
export const piMissingName = new MessageType0(MessageType.Severity.warning, null, -1, 'processing instruction does not start with valid name');
export const commentEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in comment');
export const sdCommentSignificant = new MessageType1(MessageType.Severity.error, null, -1, 'character %1 not allowed in comment (SGML declaration COM feature)');
export const markedSectionAfterDocumentElement = new MessageType0(MessageType.Severity.error, null, -1, 'marked section illegal after document element');
export const dataCharDelim = new MessageType1(MessageType.Severity.warning, null, -1, 'character %1 is the first character of a delimiter but occurred as data');
export const attributeSpecCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'character %1 not allowed in attribute specification list');
export const attributeSpecEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end not allowed in attribute specification list except in attribute value literal');
export const attributeNameShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'the name and VI delimiter can be omitted from an attribute specification only if SHORTTAG YES is specified');
export const attributeSpecLiteral = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute value literal can occur in an attribute specification list only after a VI delimiter');
export const attributeSpecNameTokenExpected = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute specification must start with a name or name token');
export const attributeTokenNotUnique = new MessageType1(MessageType.Severity.error, null, -1, 'token %1 can be value for multiple attributes so attribute name required');
export const attributeValueExpected = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute value specification must start with a literal or a name character');
export const attributeValueNotLiteral = new MessageType0(MessageType.Severity.warning, null, -1, 'attribute value not a literal');
export const attributeValueShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute value specification must be an attribute value literal unless SHORTTAG YES is specified');
export const attributeValueLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of attribute value must not exceed LITLEN less NORMSEP (%1)');
export const attributeValueLengthNeg = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of attribute value must not exceed LITLEN less NORMSEP (%1)');
export const tokenizedAttributeValueLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of tokenized attribute value must not exceed LITLEN less NORMSEP (%1)');
export const tokenizedAttributeValueLengthNeg = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of tokenized attribute value must not exceed LITLEN less NORMSEP (%1)');
export const attsplen = new MessageType2(MessageType.Severity.quantityError, null, -1, 'normalized length of attribute specification list must not exceed ATTSPLEN (%1); length was %2');
export const characterNumber = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a character number in the document character set');
export const emptyCommentDecl = new MessageType0(MessageType.Severity.warning, null, -1, 'empty comment declaration');
export const missingAttributeName = new MessageType0(MessageType.Severity.warning, null, -1, 'attribute name missing');
export const namedCharRef = new MessageType0(MessageType.Severity.warning, null, -1, 'named character reference');
export const nestcWithoutNet = new MessageType0(MessageType.Severity.error, null, -1, 'NET-enabling start-tag not immediately followed by null end-tag');
export const netEnablingStartTagShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'NET-enabling start-tag requires SHORTTAG YES');
export const noSuchAttributeToken = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a member of a group specified for any attribute');
export const nonSgmlCharRef = new MessageType0(MessageType.Severity.warning, null, -1, 'reference to non-SGML character');
export const pass2 = new MessageType0(MessageType.Severity.error, null, -1, 'unexpected entity end while starting second pass');
export const psComment = new MessageType0(MessageType.Severity.warning, null, -1, 'comment in parameter separator');
export const unclosedStartTagShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'unclosed start-tag requires SHORTTAG YES');
export const unquotedAttributeValue = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute value must be a literal unless it contains only name characters');
export const afterDocumentElementEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'end of entity other than document entity after document element');
export const characterReferenceAfterDocumentElement = new MessageType0(MessageType.Severity.error, null, -1, 'character reference illegal after document element');
export const entityReferenceAfterDocumentElement = new MessageType0(MessageType.Severity.error, null, -1, 'entity reference illegal after document element');
export const contentAsyncEntityRef = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in different element from entity reference');
export const commentDeclInvalidToken = new MessageType1(MessageType.Severity.error, null, -1, 'invalid comment declaration: found %1 outside comment but inside comment declaration');
export const commentDeclarationCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'invalid comment declaration: found character %1 outside comment but inside comment declaration');
export const commentDeclS = new MessageType0(MessageType.Severity.warning, null, -1, 'S separator in comment declaration');
export const commentDeclMultiple = new MessageType0(MessageType.Severity.warning, null, -1, 'multiple comments in comment declaration');
export const declarationLevel = new MessageType0(MessageType.Severity.error, null, -1, 'an entity end in a parameter separator must terminate an entity referenced in the same declaration');
export const functionName = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a function name');
export const refc = new MessageType0(MessageType.Severity.warning, null, -1, 'reference not terminated by REFC delimiter');
export const literalLevel = new MessageType0(MessageType.Severity.error, null, -1, 'an entity end in a literal must terminate an entity referenced in the same literal');
export const literalMinimumData = new MessageType1(MessageType.Severity.error, null, -1, 'character %1 invalid: only minimum data characters allowed');
export const literalClosingDelimiter = new MessageType0(MessageType.Severity.error, null, -1, 'literal is missing closing delimiter');
export const numericCharRefLiteralNonSgml = new MessageType1(MessageType.Severity.error, null, -1, 'illegal numeric character reference to non-SGML character %1 in literal');
export const dataTagPatternNonSgml = new MessageType0(MessageType.Severity.error, null, -1, 'a parameter literal in a data tag pattern must not contain a numeric character reference to a non-SGML character');
export const dataTagPatternFunction = new MessageType0(MessageType.Severity.error, null, -1, 'a parameter literal in a data tag pattern must not contain a numeric character reference to a function character');
export const eroGrpoStartTag = new MessageType0(MessageType.Severity.error, null, -1, 'a name group is not allowed in a general entity reference in a start tag');
export const eroGrpoProlog = new MessageType0(MessageType.Severity.error, null, -1, 'a name group is not allowed in a general entity reference in the prolog');
export const internalSubsetLiteralParamEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'reference to parameter entity in parameter literal in internal subset');
export const entityReferenceMissingName = new MessageType0(MessageType.Severity.error, null, -1, 'missing name after entity reference open delimiter');
export const parameterEntityNameLength = new MessageType1(MessageType.Severity.error, null, -1, 'parameter entity name exceeds NAMELEN limit (%1)');
export const entityUndefined = new MessageType1(MessageType.Severity.error, null, -1, 'general entity %1 not defined and no default entity');
export const parameterEntityUndefined = new MessageType1(MessageType.Severity.error, null, -1, 'parameter entity %1 not defined');
export const entityApplicableDtd = new MessageType0(MessageType.Severity.error, null, -1, 'cannot reference entity before applicable DTD');
export const defaultEntityReference = new MessageType1(MessageType.Severity.warning, null, -1, 'reference to entity %1 uses default entity');
export const piEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'reference to PI entity');
export const attributeValueExternalEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'reference to external entity in attribute value');
export const nonExistentEntityRef = new MessageType1(MessageType.Severity.error, null, -1, 'reference to non-existent entity %1');
export const externalDataEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'reference to external data entity');
export const externalNonTextEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'reference to external non-text entity');
export const externalNonTextEntityRcdata = new MessageType0(MessageType.Severity.error, null, -1, 'reference to external non-text entity in literal or RCDATA');
export const dtdDataEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'reference to data entity in DTD');
export const entlvl = new MessageType1(MessageType.Severity.error, null, -1, 'entity nesting level exceeds ENTLVL limit (%1)');
export const recursiveEntityReference = new MessageType1(MessageType.Severity.error, null, -1, 'recursive reference to entity %1');
export const entityRefNone = new MessageType0(MessageType.Severity.error, null, -1, 'entity reference not allowed (SGML declaration: ENTITYREF NONE)');
export const entityRefInternal = new MessageType0(MessageType.Severity.error, null, -1, 'external entity reference not allowed (SGML declaration: ENTITYREF INTERNAL)');
export const internalDataEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'a reference to a CDATA or SDATA entity is allowed only in a context where a data character could occur');
export const instanceStartOmittag = new MessageType0(MessageType.Severity.error, null, -1, 'document instance must start with document element');
export const duplicateAttributeSpec = new MessageType1(MessageType.Severity.error, null, -1, 'duplicate specification of attribute %1');
export const conrefNotation = new MessageType0(MessageType.Severity.error, null, -1, 'value cannot be specified both for notation attribute and content reference attribute');
export const idrefGrpcnt = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of ID references in start-tag must not exceed GRPCNT (%1)');
export const entityNameGrpcnt = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of entity names in attribute specification list must not exceed GRPCNT (%1)');
export const undefinedElement = new MessageType1(MessageType.Severity.error, null, -1, 'element %1 undefined');
export const elementNotAllowed = new MessageType1(MessageType.Severity.error, null, -1, 'document type does not allow element %1 here');
export const missingElementMultiple = new MessageType2(MessageType.Severity.error, null, -1, 'document type does not allow element %1 here; missing one of %2 start-tag');
export const missingElementInferred = new MessageType2(MessageType.Severity.error, null, -1, 'document type does not allow element %1 here; assuming missing %2 start-tag');
export const startTagEmptyElement = new MessageType1(MessageType.Severity.error, null, -1, 'no start tag specified for implied empty element %1');
export const omitEndTagDeclare = new MessageType1(MessageType.Severity.error, null, -1, 'end tag for %1 omitted, but its declaration does not permit this');
export const omitEndTagOmittag = new MessageType1(MessageType.Severity.error, null, -1, 'end tag for %1 omitted, but OMITTAG NO was specified');
export const omitStartTagDeclaredContent = new MessageType1(MessageType.Severity.error, null, -1, 'start tag omitted for element %1 with declared content');
export const omitStartTagDeclare = new MessageType1(MessageType.Severity.error, null, -1, 'start tag for %1 omitted, but its declaration does not permit this');
export const taglvlOpenElements = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of open elements exceeds TAGLVL (%1)');
export const elementNotOpen = new MessageType1(MessageType.Severity.error, null, -1, 'end tag for element %1 which is not open');
export const requiredElementExcluded = new MessageType3(MessageType.Severity.error, null, -1, 'the %1 occurrence of %2 in the content model for %3 cannot be excluded at this point because it is contextually required');
export const invalidExclusion = new MessageType3(MessageType.Severity.error, null, -1, 'the %1 occurrence of %2 in the content model for %3 cannot be excluded because it is neither inherently optional nor a member of an OR group');
export const immediateRecursion = new MessageType0(MessageType.Severity.warning, null, -1, 'immediately recursive element');
export const lexicalAmbiguity = new MessageType2(MessageType.Severity.warning, null, -1, 'delimiter %1 and %2 are ambiguous');

// Messages from parseParam.cxx
export const markupDeclarationCharacter = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid: only %2 are allowed');
export const parameterEntityNotEnded = new MessageType0(MessageType.Severity.error, null, -1, 'parameter entity not ended at end of declaration');
export const groupLevel = new MessageType0(MessageType.Severity.error, null, -1, 'an entity end in a token separator must terminate an entity referenced in the same group');
export const groupEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end within a group');
export const paramInvalidToken = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid: only %2 are allowed');
export const groupCharacter = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid in group: only %2 are allowed');
export const groupTokenInvalidToken = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid: only %2 are allowed');
export const connectorInvalidToken = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid: only %2 are allowed');
export const duplicateGroupToken = new MessageType1(MessageType.Severity.error, null, -1, 'duplicate token %1 in group');
export const groupCount = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of tokens in group exceeds GRPCNT (%1)');
export const mixedConnectors = new MessageType0(MessageType.Severity.warning, null, -1, 'mixed connectors in model group');
export const nameGroupNotOr = new MessageType0(MessageType.Severity.warning, null, -1, 'name group should use | (OR) connector');
export const grplvl = new MessageType1(MessageType.Severity.quantityError, null, -1, 'group nesting level exceeds GRPLVL (%1)');
export const pcdataNotFirstInGroup = new MessageType0(MessageType.Severity.warning, null, -1, '#PCDATA should be first in model group');
export const pcdataInSeqGroup = new MessageType0(MessageType.Severity.warning, null, -1, '#PCDATA in model group with , (SEQ) connector');
export const pcdataInNestedModelGroup = new MessageType0(MessageType.Severity.warning, null, -1, '#PCDATA in nested model group');
export const pcdataGroupMemberModelGroup = new MessageType0(MessageType.Severity.warning, null, -1, 'model group containing #PCDATA has member that is a model group');
export const pcdataGroupMemberOccurrenceIndicator = new MessageType0(MessageType.Severity.warning, null, -1, 'model group containing #PCDATA has member with occurrence indicator');
export const pcdataGroupNotRep = new MessageType0(MessageType.Severity.warning, null, -1, 'model group containing #PCDATA does not have * (REP) occurrence indicator');
export const minimumLiteralLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of minimum literal must not exceed %1 characters');
export const systemIdentifierLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of system identifier must not exceed %1 characters');
export const parameterLiteralLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of parameter literal must not exceed %1 characters');
export const dataTagPatternLiteralLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of data tag pattern literal must not exceed %1 characters');
export const invalidReservedName = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a valid reserved name');
export const noSuchReservedName = new MessageType1(MessageType.Severity.error, null, -1, 'there is no reserved name %1');
export const rniNameStart = new MessageType0(MessageType.Severity.error, null, -1, 'name character expected after RNI');
export const instanceParamEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'parameter entity reference in document instance');
export const internalSubsetPsParamEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'parameter entity reference in parameter separator in internal subset');
export const internalSubsetTsParamEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'parameter entity reference in token separator in internal subset');
export const peroGrpoStartTag = new MessageType0(MessageType.Severity.error, null, -1, 'parameter entity reference in start tag');
export const peroGrpoEndTag = new MessageType0(MessageType.Severity.error, null, -1, 'parameter entity reference in end tag');
export const groupEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'entity reference in group');
export const datatagNotImplemented = new MessageType0(MessageType.Severity.error, null, -1, 'DATATAG not implemented');
export const datatagBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'DATATAG requires base DTD');
export const andGroup = new MessageType0(MessageType.Severity.warning, null, -1, 'AND group in content model');
export const groupParameterEntityNotEnded = new MessageType0(MessageType.Severity.error, null, -1, 'parameter entity not ended within group');
export const sorryAllImplicit = new MessageType0(MessageType.Severity.error, null, -1, '#ALL and #IMPLICIT not supported');
export const groupTokenInvalidReservedName = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not allowed in this context');

// Marked section messages
export const markedSectionLevel = new MessageType1(MessageType.Severity.error, null, -1, 'number of open marked sections must not exceed TAGLVL (%1)');
export const markedSectionEnd = new MessageType0(MessageType.Severity.error, null, -1, 'marked section end not in marked section declaration');
export const tempMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'TEMP marked section');
export const instanceIncludeMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'included marked section in the instance');
export const instanceIgnoreMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'ignored marked section in the instance');
export const rcdataMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'RCDATA marked section');
export const missingStatusKeyword = new MessageType0(MessageType.Severity.warning, null, -1, 'no status keyword');
export const multipleStatusKeyword = new MessageType0(MessageType.Severity.warning, null, -1, 'multiple status keywords');
export const instanceStatusKeywordSpecS = new MessageType0(MessageType.Severity.warning, null, -1, 'S separator in status keyword specification in document instance');
export const internalSubsetMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'marked section in internal DTD subset');
