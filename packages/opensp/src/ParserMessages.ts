// Copyright (c) 1994 James Clark
// See the file COPYING for copying permission.

// Parser message types
// This is a stub implementation for now - full message definitions would come from ParserMessages.msg

import { MessageType0, MessageType1, MessageType2, MessageType3, MessageType5, MessageType6, MessageType, MessageType0L, MessageType1L } from './Message';

export const pass2Ee = new MessageType0(MessageType.Severity.error, null, -1, 'pass 2 error');
export const peroGrpoProlog = new MessageType0(MessageType.Severity.error, null, -1, 'a name group is not allowed in a parameter entity reference in the prolog');
export const noSuchDeclarationType = new MessageType1(MessageType.Severity.error, null, -1, 'unknown declaration type %1');
export const instanceDeclaration = new MessageType1(MessageType.Severity.error, null, -1, '%1 declaration not allowed in instance');
export const declarationAfterDocumentElement = new MessageType1(MessageType.Severity.error, null, -1, '%1 declaration after document element');
export const dtdSubsetDeclaration = new MessageType1(MessageType.Severity.error, null, -1, '%1 declaration not allowed in DTD subset');
export const declSubsetCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'character %1 not allowed in declaration subset');
export const documentEndDtdSubset = new MessageType0(MessageType.Severity.error, null, -1, 'end of document in DTD subset');
export const specialParseEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in character data, replaceable character data or ignored marked section');
export const dataMarkedSectionDeclSubset = new MessageType0(MessageType.Severity.error, null, -1, 'data or replaceable character data in declaration subset');
export const documentEndLpdSubset = new MessageType0(MessageType.Severity.error, null, -1, 'end of document in LPD subset');
export const lpdSubsetDeclaration = new MessageType1(MessageType.Severity.error, null, -1, '%1 declaration not allowed in LPD subset');
export const activeDocLink = new MessageType0(MessageType.Severity.error, null, -1, 'active document link');
export const sorryActiveDoctypes = new MessageType0(MessageType.Severity.error, null, -1, 'sorry, multiple active doctypes not supported');
export const linkActivateTooLate = new MessageType0(MessageType.Severity.warning, null, -1, 'link type activation too late');
export const defaultEntityInAttribute = new MessageType1(MessageType.Severity.warning, null, -1, 'default entity reference in attribute: %1');
export const unstableLpdParameterEntity = new MessageType1(MessageType.Severity.error, null, -1, 'unstable LPD parameter entity: %1');
export const unstableLpdGeneralEntity = new MessageType1(MessageType.Severity.error, null, -1, 'unstable LPD general entity: %1');
export const concurrentInstances = new MessageType1(MessageType.Severity.error, null, -1, 'too many concurrent instances: %1');
export const giveUp = new MessageType0(MessageType.Severity.error, null, -1, 'cannot continue because of previous errors');
export const subdocGiveUp = new MessageType0(MessageType.Severity.error, null, -1, 'cannot continue with subdocument because of previous errors');
export const subdocLevel = new MessageType1(MessageType.Severity.error, null, -1, 'number of open subdocuments exceeds quantity specified for SUBDOC parameter in SGML declaration (%1)');
export const numberLength = new MessageType1(MessageType.Severity.error, null, -1, 'number token exceeds NAMELEN limit (%1)');
export const nameTokenLength = new MessageType1(MessageType.Severity.error, null, -1, 'name token exceeds NAMELEN limit (%1)');
export const normalizedAttributeValueLength = new MessageType2(MessageType.Severity.quantityError, null, -1, 'normalized length of attribute value literal must not exceed LITLEN (%1); length was %2');
export const attributeValueSyntax = new MessageType0(MessageType.Severity.error, null, -1, 'syntax of attribute value does not conform to declared value');
export const attributeValueChar = new MessageType2(MessageType.Severity.error, null, -1, 'character %1 is not allowed in the value of attribute %2');
export const attributeValueMultiple = new MessageType1(MessageType.Severity.error, null, -1, 'value of attribute %1 must be a single token');
export const attributeValueNumberToken = new MessageType2(MessageType.Severity.error, null, -1, 'value of attribute %2 invalid: %1 cannot start a number token');
export const attributeValueName = new MessageType2(MessageType.Severity.error, null, -1, 'value of attribute %2 invalid: %1 cannot start a name');
export const nonSgmlCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'non-SGML character number %1');
export const nameLength = new MessageType1(MessageType.Severity.error, null, -1, 'name exceeds NAMELEN limit (%1)');
export const endTagCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'invalid character in end tag: %1');
export const endTagEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in end tag');
export const unclosedEndTagShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'unclosed end tag (shorttag feature required)');
export const endTagInvalidToken = new MessageType1(MessageType.Severity.error, null, -1, 'invalid token in end tag: %1');
export const emptyEndTag = new MessageType0(MessageType.Severity.warning, null, -1, 'empty end tag');
export const emptyStartTag = new MessageType0(MessageType.Severity.warning, null, -1, 'empty start tag');
export const emptyEndTagNoOpenElements = new MessageType0(MessageType.Severity.error, null, -1, 'empty end tag with no open elements');
export const emptyEndTagBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'empty end tag not in base DTD');
export const emptyStartTagBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'empty start tag not in base DTD');
export const elementNotFinished = new MessageType1(MessageType.Severity.error, null, -1, 'element %1 not finished');
export const elementEndTagNotFinished = new MessageType1(MessageType.Severity.error, null, -1, 'end tag for element %1 which is not finished');
export const taglen = new MessageType1(MessageType.Severity.error, null, -1, 'length of start tag exceeds TAGLEN limit (%1)');
export const noCurrentRank = new MessageType1(MessageType.Severity.error, null, -1, 'no current rank for %1');
export const startTagMissingName = new MessageType0(MessageType.Severity.error, null, -1, 'missing name in start tag');
export const endTagMissingName = new MessageType0(MessageType.Severity.error, null, -1, 'missing name in end tag');
export const startTagGroupNet = new MessageType0(MessageType.Severity.error, null, -1, 'NET delimiter in group start tag');
export const processingInstructionEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in processing instruction');
export const processingInstructionLength = new MessageType1(MessageType.Severity.error, null, -1, 'processing instruction length exceeds PILEN limit (%1)');
export const processingInstructionClose = new MessageType0(MessageType.Severity.error, null, -1, 'missing processing instruction close');
export const piMissingName = new MessageType0(MessageType.Severity.warning, null, -1, 'processing instruction does not start with valid name');
export const commentEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in comment');
export const sdCommentSignificant = new MessageType1(MessageType.Severity.error, null, -1, 'character %1 not allowed in comment (SGML declaration COM feature)');
export const markedSectionAfterDocumentElement = new MessageType0(MessageType.Severity.error, null, -1, 'marked section illegal after document element');
export const dataCharDelim = new MessageType1(MessageType.Severity.warning, null, -1, 'character %1 is the first character of a delimiter but occurred as data');
export const attributeSpecCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'character %1 not allowed in attribute specification list');
export const attributeSpecEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end not allowed in attribute specification list except in attribute value literal');
export const attributeNameShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'the name and VI delimiter can be omitted from an attribute specification only if SHORTTAG YES is specified');
export const attributeSpecLiteral = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute value literal can occur in an attribute specification list only after a VI delimiter');
export const attributeSpecNameTokenExpected = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute specification must start with a name or name token');
export const attributeTokenNotUnique = new MessageType1(MessageType.Severity.error, null, -1, 'token %1 can be value for multiple attributes so attribute name required');
export const attributeValueExpected = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute value specification must start with a literal or a name character');
export const attributeValueNotLiteral = new MessageType0(MessageType.Severity.warning, null, -1, 'attribute value not a literal');
export const attributeValueShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute value specification must be an attribute value literal unless SHORTTAG YES is specified');
export const attributeValueLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of attribute value must not exceed LITLEN less NORMSEP (%1)');
export const attributeValueLengthNeg = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of attribute value must not exceed LITLEN less NORMSEP (%1)');
export const tokenizedAttributeValueLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of tokenized attribute value must not exceed LITLEN less NORMSEP (%1)');
export const tokenizedAttributeValueLengthNeg = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of tokenized attribute value must not exceed LITLEN less NORMSEP (%1)');
export const attsplen = new MessageType2(MessageType.Severity.quantityError, null, -1, 'normalized length of attribute specification list must not exceed ATTSPLEN (%1); length was %2');
export const characterNumber = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a character number in the document character set');
export const emptyCommentDecl = new MessageType0(MessageType.Severity.warning, null, -1, 'empty comment declaration');
export const missingAttributeName = new MessageType0(MessageType.Severity.warning, null, -1, 'attribute name missing');
export const namedCharRef = new MessageType0(MessageType.Severity.warning, null, -1, 'named character reference');
export const nestcWithoutNet = new MessageType0(MessageType.Severity.error, null, -1, 'NET-enabling start-tag not immediately followed by null end-tag');
export const netEnablingStartTagShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'NET-enabling start-tag requires SHORTTAG YES');
export const noSuchAttributeToken = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a member of a group specified for any attribute');
export const nonSgmlCharRef = new MessageType0(MessageType.Severity.warning, null, -1, 'reference to non-SGML character');
export const pass2 = new MessageType0(MessageType.Severity.error, null, -1, 'unexpected entity end while starting second pass');
export const psComment = new MessageType0(MessageType.Severity.warning, null, -1, 'comment in parameter separator');
export const unclosedStartTagShorttag = new MessageType0(MessageType.Severity.error, null, -1, 'unclosed start-tag requires SHORTTAG YES');
export const unquotedAttributeValue = new MessageType0(MessageType.Severity.error, null, -1, 'an attribute value must be a literal unless it contains only name characters');
export const afterDocumentElementEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'end of entity other than document entity after document element');
export const characterReferenceAfterDocumentElement = new MessageType0(MessageType.Severity.error, null, -1, 'character reference illegal after document element');
export const entityReferenceAfterDocumentElement = new MessageType0(MessageType.Severity.error, null, -1, 'entity reference illegal after document element');
export const contentAsyncEntityRef = new MessageType0(MessageType.Severity.error, null, -1, 'entity end in different element from entity reference');
export const commentDeclInvalidToken = new MessageType1(MessageType.Severity.error, null, -1, 'invalid comment declaration: found %1 outside comment but inside comment declaration');
export const commentDeclarationCharacter = new MessageType1(MessageType.Severity.error, null, -1, 'invalid comment declaration: found character %1 outside comment but inside comment declaration');
export const commentDeclS = new MessageType0(MessageType.Severity.warning, null, -1, 'S separator in comment declaration');
export const commentDeclMultiple = new MessageType0(MessageType.Severity.warning, null, -1, 'multiple comments in comment declaration');
export const declarationLevel = new MessageType0(MessageType.Severity.error, null, -1, 'an entity end in a parameter separator must terminate an entity referenced in the same declaration');
export const functionName = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a function name');
export const refc = new MessageType0(MessageType.Severity.warning, null, -1, 'reference not terminated by REFC delimiter');
export const literalLevel = new MessageType0(MessageType.Severity.error, null, -1, 'an entity end in a literal must terminate an entity referenced in the same literal');
export const literalMinimumData = new MessageType1(MessageType.Severity.error, null, -1, 'character %1 invalid: only minimum data characters allowed');
export const literalClosingDelimiter = new MessageType0(MessageType.Severity.error, null, -1, 'literal is missing closing delimiter');
export const numericCharRefLiteralNonSgml = new MessageType1(MessageType.Severity.error, null, -1, 'illegal numeric character reference to non-SGML character %1 in literal');
export const dataTagPatternNonSgml = new MessageType0(MessageType.Severity.error, null, -1, 'a parameter literal in a data tag pattern must not contain a numeric character reference to a non-SGML character');
export const dataTagPatternFunction = new MessageType0(MessageType.Severity.error, null, -1, 'a parameter literal in a data tag pattern must not contain a numeric character reference to a function character');
export const eroGrpoStartTag = new MessageType0(MessageType.Severity.error, null, -1, 'a name group is not allowed in a general entity reference in a start tag');
export const eroGrpoProlog = new MessageType0(MessageType.Severity.error, null, -1, 'a name group is not allowed in a general entity reference in the prolog');
export const internalSubsetLiteralParamEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'reference to parameter entity in parameter literal in internal subset');
export const entityReferenceMissingName = new MessageType0(MessageType.Severity.error, null, -1, 'missing name after entity reference open delimiter');
export const parameterEntityNameLength = new MessageType1(MessageType.Severity.error, null, -1, 'parameter entity name exceeds NAMELEN limit (%1)');
export const entityUndefined = new MessageType1(MessageType.Severity.error, null, -1, 'general entity %1 not defined and no default entity');
export const parameterEntityUndefined = new MessageType1(MessageType.Severity.error, null, -1, 'parameter entity %1 not defined');
export const entityApplicableDtd = new MessageType0(MessageType.Severity.error, null, -1, 'cannot reference entity before applicable DTD');
export const defaultEntityReference = new MessageType1(MessageType.Severity.warning, null, -1, 'reference to entity %1 uses default entity');
export const piEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'reference to PI entity');
export const attributeValueExternalEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'reference to external entity in attribute value');
export const nonExistentEntityRef = new MessageType1(MessageType.Severity.error, null, -1, 'reference to non-existent entity %1');
export const externalDataEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'reference to external data entity');
export const externalNonTextEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'reference to external non-text entity');
export const externalNonTextEntityRcdata = new MessageType0(MessageType.Severity.error, null, -1, 'reference to external non-text entity in literal or RCDATA');
export const dtdDataEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'reference to data entity in DTD');
export const entlvl = new MessageType1(MessageType.Severity.error, null, -1, 'entity nesting level exceeds ENTLVL limit (%1)');
export const recursiveEntityReference = new MessageType1(MessageType.Severity.error, null, -1, 'recursive reference to entity %1');
export const entityRefNone = new MessageType0(MessageType.Severity.error, null, -1, 'entity reference not allowed (SGML declaration: ENTITYREF NONE)');
export const entityRefInternal = new MessageType0(MessageType.Severity.error, null, -1, 'external entity reference not allowed (SGML declaration: ENTITYREF INTERNAL)');
export const internalDataEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'a reference to a CDATA or SDATA entity is allowed only in a context where a data character could occur');
export const instanceStartOmittag = new MessageType0(MessageType.Severity.error, null, -1, 'document instance must start with document element');
export const duplicateAttributeSpec = new MessageType1(MessageType.Severity.error, null, -1, 'duplicate specification of attribute %1');
export const conrefNotation = new MessageType0(MessageType.Severity.error, null, -1, 'value cannot be specified both for notation attribute and content reference attribute');
export const idrefGrpcnt = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of ID references in start-tag must not exceed GRPCNT (%1)');
export const entityNameGrpcnt = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of entity names in attribute specification list must not exceed GRPCNT (%1)');
export const invalidEntityAttribute = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a general entity name');
export const notDataOrSubdocEntity = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a data or subdocument entity');
export const invalidNotationAttribute = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a notation name');
export const undefinedElement = new MessageType1(MessageType.Severity.error, null, -1, 'element %1 undefined');
export const elementNotAllowed = new MessageType1(MessageType.Severity.error, null, -1, 'document type does not allow element %1 here');
export const missingElementMultiple = new MessageType2(MessageType.Severity.error, null, -1, 'document type does not allow element %1 here; missing one of %2 start-tag');
export const missingElementInferred = new MessageType2(MessageType.Severity.error, null, -1, 'document type does not allow element %1 here; assuming missing %2 start-tag');
export const startTagEmptyElement = new MessageType1(MessageType.Severity.error, null, -1, 'no start tag specified for implied empty element %1');
export const omitEndTagDeclare = new MessageType1L(MessageType.Severity.error, null, -1, 'end tag for %1 omitted, but its declaration does not permit this', null, 'start tag was here');
export const omitEndTagOmittag = new MessageType1L(MessageType.Severity.error, null, -1, 'end tag for %1 omitted, but OMITTAG NO was specified', null, 'start tag was here');
export const omitStartTagDeclaredContent = new MessageType1(MessageType.Severity.error, null, -1, 'start tag omitted for element %1 with declared content');
export const omitStartTagDeclare = new MessageType1(MessageType.Severity.error, null, -1, 'start tag for %1 omitted, but its declaration does not permit this');
export const taglvlOpenElements = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of open elements exceeds TAGLVL (%1)');
export const elementNotOpen = new MessageType1(MessageType.Severity.error, null, -1, 'end tag for element %1 which is not open');
export const requiredElementExcluded = new MessageType3(MessageType.Severity.error, null, -1, 'the %1 occurrence of %2 in the content model for %3 cannot be excluded at this point because it is contextually required');
export const invalidExclusion = new MessageType3(MessageType.Severity.error, null, -1, 'the %1 occurrence of %2 in the content model for %3 cannot be excluded because it is neither inherently optional nor a member of an OR group');
export const immediateRecursion = new MessageType0(MessageType.Severity.warning, null, -1, 'immediately recursive element');
export const pcdataNotAllowed = new MessageType0(MessageType.Severity.error, null, -1, 'character data is not allowed here');
export const elementNotFinishedDocumentEnd = new MessageType1(MessageType.Severity.error, null, -1, '%1 not finished but document ended');
export const noDocumentElement = new MessageType0(MessageType.Severity.error, null, -1, 'no document element');
export const unclosedMarkedSection = new MessageType0L(MessageType.Severity.error, null, -1, 'missing marked section end', 'marked section started here');
export const missingId = new MessageType1(MessageType.Severity.idrefError, null, -1, 'reference to non-existent ID %1');
export const lexicalAmbiguity = new MessageType2(MessageType.Severity.warning, null, -1, 'delimiter %1 and %2 are ambiguous');

// Messages from parseParam.cxx
export const markupDeclarationCharacter = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid: only %2 are allowed');
export const parameterEntityNotEnded = new MessageType0(MessageType.Severity.error, null, -1, 'parameter entity not ended at end of declaration');
export const groupLevel = new MessageType0(MessageType.Severity.error, null, -1, 'an entity end in a token separator must terminate an entity referenced in the same group');
export const groupEntityEnd = new MessageType0(MessageType.Severity.error, null, -1, 'entity end within a group');
export const paramInvalidToken = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid: only %2 are allowed');
export const groupCharacter = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid in group: only %2 are allowed');
export const groupTokenInvalidToken = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid: only %2 are allowed');
export const connectorInvalidToken = new MessageType2(MessageType.Severity.error, null, -1, '%1 invalid: only %2 are allowed');
export const duplicateGroupToken = new MessageType1(MessageType.Severity.error, null, -1, 'duplicate token %1 in group');
export const groupCount = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of tokens in group exceeds GRPCNT (%1)');
export const mixedConnectors = new MessageType0(MessageType.Severity.warning, null, -1, 'mixed connectors in model group');
export const nameGroupNotOr = new MessageType0(MessageType.Severity.warning, null, -1, 'name group should use | (OR) connector');
export const grplvl = new MessageType1(MessageType.Severity.quantityError, null, -1, 'group nesting level exceeds GRPLVL (%1)');
export const pcdataNotFirstInGroup = new MessageType0(MessageType.Severity.warning, null, -1, '#PCDATA should be first in model group');
export const pcdataInSeqGroup = new MessageType0(MessageType.Severity.warning, null, -1, '#PCDATA in model group with , (SEQ) connector');
export const pcdataInNestedModelGroup = new MessageType0(MessageType.Severity.warning, null, -1, '#PCDATA in nested model group');
export const pcdataGroupMemberModelGroup = new MessageType0(MessageType.Severity.warning, null, -1, 'model group containing #PCDATA has member that is a model group');
export const pcdataGroupMemberOccurrenceIndicator = new MessageType0(MessageType.Severity.warning, null, -1, 'model group containing #PCDATA has member with occurrence indicator');
export const pcdataGroupNotRep = new MessageType0(MessageType.Severity.warning, null, -1, 'model group containing #PCDATA does not have * (REP) occurrence indicator');
export const minimumLiteralLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of minimum literal must not exceed %1 characters');
export const systemIdentifierLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of system identifier must not exceed %1 characters');
export const parameterLiteralLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of parameter literal must not exceed %1 characters');
export const dataTagPatternLiteralLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of data tag pattern literal must not exceed %1 characters');
export const invalidReservedName = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a valid reserved name');
export const noSuchReservedName = new MessageType1(MessageType.Severity.error, null, -1, 'there is no reserved name %1');
export const rniNameStart = new MessageType0(MessageType.Severity.error, null, -1, 'name character expected after RNI');
export const instanceParamEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'parameter entity reference in document instance');
export const internalSubsetPsParamEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'parameter entity reference in parameter separator in internal subset');
export const internalSubsetTsParamEntityRef = new MessageType0(MessageType.Severity.warning, null, -1, 'parameter entity reference in token separator in internal subset');
export const peroGrpoStartTag = new MessageType0(MessageType.Severity.error, null, -1, 'parameter entity reference in start tag');
export const peroGrpoEndTag = new MessageType0(MessageType.Severity.error, null, -1, 'parameter entity reference in end tag');
export const groupEntityReference = new MessageType0(MessageType.Severity.error, null, -1, 'entity reference in group');
export const datatagNotImplemented = new MessageType0(MessageType.Severity.error, null, -1, 'DATATAG not implemented');
export const datatagBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'DATATAG requires base DTD');
export const andGroup = new MessageType0(MessageType.Severity.warning, null, -1, 'AND group in content model');
export const groupParameterEntityNotEnded = new MessageType0(MessageType.Severity.error, null, -1, 'parameter entity not ended within group');
export const sorryAllImplicit = new MessageType0(MessageType.Severity.error, null, -1, '#ALL and #IMPLICIT not supported');
export const groupTokenInvalidReservedName = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not allowed in this context');

// Marked section messages
export const markedSectionLevel = new MessageType1(MessageType.Severity.error, null, -1, 'number of open marked sections must not exceed TAGLVL (%1)');
export const markedSectionEnd = new MessageType0(MessageType.Severity.error, null, -1, 'marked section end not in marked section declaration');
export const tempMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'TEMP marked section');
export const instanceIncludeMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'included marked section in the instance');
export const instanceIgnoreMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'ignored marked section in the instance');
export const rcdataMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'RCDATA marked section');
export const missingStatusKeyword = new MessageType0(MessageType.Severity.warning, null, -1, 'no status keyword');
export const multipleStatusKeyword = new MessageType0(MessageType.Severity.warning, null, -1, 'multiple status keywords');
export const instanceStatusKeywordSpecS = new MessageType0(MessageType.Severity.warning, null, -1, 'S separator in status keyword specification in document instance');
export const internalSubsetMarkedSection = new MessageType0(MessageType.Severity.warning, null, -1, 'marked section in internal DTD subset');

// Element declaration messages
export const elementGroupDecl = new MessageType0(MessageType.Severity.warning, null, -1, 'element type name group in element declaration');
export const rank = new MessageType0(MessageType.Severity.warning, null, -1, 'RANK feature');
export const genericIdentifierLength = new MessageType1(MessageType.Severity.quantityError, null, -1, 'generic identifier length must not exceed NAMELEN (%1)');
export const rankStemGenericIdentifier = new MessageType1(MessageType.Severity.error, null, -1, '%1 cannot be a generic identifier because it was used as a rank stem');
export const psRequired = new MessageType0(MessageType.Severity.error, null, -1, 'parameter separator required');
export const minimizationParam = new MessageType0(MessageType.Severity.warning, null, -1, 'tag minimization parameter specified');
export const missingTagMinimization = new MessageType0(MessageType.Severity.error, null, -1, 'tag minimization parameter missing');
export const cdataContent = new MessageType0(MessageType.Severity.warning, null, -1, 'CDATA declared content');
export const rcdataContent = new MessageType0(MessageType.Severity.warning, null, -1, 'RCDATA declared content');
export const emptyOmitEndTag = new MessageType0(MessageType.Severity.warning, null, -1, 'should be declared with O end-tag minimization');
export const grpgtcnt = new MessageType1(MessageType.Severity.quantityError, null, -1, 'number of content tokens exceeds GRPGTCNT (%1)');
export const pcdataUnreachable = new MessageType0(MessageType.Severity.warning, null, -1, '#PCDATA in mixed content model unreachable');
export const duplicateElementDefinition = new MessageType1(MessageType.Severity.error, null, -1, 'duplicate definition of element %1');
export const ambiguousModelInitial = new MessageType3(MessageType.Severity.error, null, -1, 'content model is ambiguous: when the start-tag has been parsed, the %1 contained in content token %2 and the %1 contained in content token %3 are both possible');
export const ambiguousModel = new MessageType5(MessageType.Severity.error, null, -1, 'content model is ambiguous: when the %1 contained in content token %2 has been matched, the %3 contained in content token %4 and the %3 contained in content token %5 are both possible');
export const ambiguousModelSingleAnd = new MessageType5(MessageType.Severity.error, null, -1, 'content model is ambiguous: when the %1 contained in content token %2 has been matched and the connector after an AND group has been matched, the %3 contained in content token %4 and the %3 contained in content token %5 are both possible');
export const ambiguousModelMultipleAnd = new MessageType6(MessageType.Severity.error, null, -1, 'content model is ambiguous: when the %1 contained in content token %2 has been matched and the connectors after %3 AND groups have been matched, the %4 contained in content token %5 and the %4 contained in content token %6 are both possible');
export const exclusion = new MessageType0(MessageType.Severity.warning, null, -1, 'exclusion exception');
export const inclusion = new MessageType0(MessageType.Severity.warning, null, -1, 'inclusion exception');
export const excludeIncludeSame = new MessageType1(MessageType.Severity.error, null, -1, '%1 appears in both inclusion and exclusion');
export const conrefEmpty = new MessageType1(MessageType.Severity.error, null, -1, 'element %1 has a declared content of EMPTY and a CONREF attribute');
export const notationEmpty = new MessageType1(MessageType.Severity.error, null, -1, 'element %1 has a declared content of EMPTY and a NOTATION attribute');

// Notation declaration messages
export const notationIdentifierTextClass = new MessageType0(MessageType.Severity.error, null, -1, 'public text class of public identifier in notation identifier must be NOTATION');
export const duplicateNotationDeclaration = new MessageType1(MessageType.Severity.error, null, -1, 'notation %1 already defined');
export const notationMustNotBeDeclared = new MessageType1(MessageType.Severity.error, null, -1, '#IMPLICIT attributes have already been specified for notation %1');
export const missingSystemId = new MessageType0(MessageType.Severity.warning, null, -1, 'no system identifier specified');
export const wwwRequired = new MessageType0(MessageType.Severity.warning, null, -1, 'public identifier in formal public identifier form requires WWW feature');

// Entity declaration messages
export const internalParameterDataEntity = new MessageType1(MessageType.Severity.error, null, -1, 'internal parameter entity %1 cannot be CDATA or SDATA');
export const externalParameterDataSubdocEntity = new MessageType1(MessageType.Severity.error, null, -1, 'external parameter entity %1 cannot be CDATA, SDATA, NDATA or SUBDOC');
export const duplicateEntityDeclaration = new MessageType1(MessageType.Severity.warning, null, -1, 'duplicate declaration of entity %1');
export const duplicateParameterEntityDeclaration = new MessageType1(MessageType.Severity.warning, null, -1, 'duplicate declaration of parameter entity %1');
export const emptyDataAttributeSpec = new MessageType0(MessageType.Severity.error, null, -1, 'data attribute specification must be omitted if attribute specification list is empty');
export const subdocEntity = new MessageType1(MessageType.Severity.error, null, -1, 'entity %1 declared SUBDOC, but SUBDOC NO specified in SGML declaration');
export const notationNoAttributes = new MessageType1(MessageType.Severity.error, null, -1, 'no attributes defined for notation %1');
export const bracketedLitlen = new MessageType1(MessageType.Severity.quantityError, null, -1, 'length of interpreted parameter literal in bracketed text plus the length of the bracketing delimiters must not exceed LITLEN (%1)');
export const defaultedEntityDefined = new MessageType1(MessageType.Severity.warning, null, -1, 'earlier reference to entity %1 used default entity');
export const piEntity = new MessageType0(MessageType.Severity.warning, null, -1, 'processing instruction entity');
export const bracketEntity = new MessageType0(MessageType.Severity.warning, null, -1, 'bracketed text entity');
export const internalCdataEntity = new MessageType0(MessageType.Severity.warning, null, -1, 'internal CDATA entity');
export const internalSdataEntity = new MessageType0(MessageType.Severity.warning, null, -1, 'internal SDATA entity');
export const externalCdataEntity = new MessageType0(MessageType.Severity.warning, null, -1, 'external CDATA entity');
export const externalSdataEntity = new MessageType0(MessageType.Severity.warning, null, -1, 'external SDATA entity');
export const defaultEntityDecl = new MessageType0(MessageType.Severity.warning, null, -1, 'declaration of default entity');
export const implydefEntityDefault = new MessageType0(MessageType.Severity.error, null, -1, 'declaration of default entity conflicts with IMPLYDEF ENTITY YES');

// Attribute list declaration messages
export const duplicateAttributeDef = new MessageType1(MessageType.Severity.error, null, -1, 'duplicate definition of attribute %1');
export const multipleIdAttributes = new MessageType1(MessageType.Severity.error, null, -1, 'more than one ID attribute for element %1');
export const duplicateId = new MessageType1L(MessageType.Severity.error, null, -1, 'ID %1 already defined', null, 'ID %1 first defined here');
export const multipleNotationAttributes = new MessageType1(MessageType.Severity.error, null, -1, 'more than one NOTATION attribute for element %1');
export const duplicateAttributeToken = new MessageType1(MessageType.Severity.error, null, -1, 'token %1 occurs more than once in attribute definition list');
export const dataAttributeDeclaredValue = new MessageType0(MessageType.Severity.error, null, -1, 'declared value for data attribute must be CDATA or NAME or NAMES or NMTOKEN or NMTOKENS or NUTOKEN or NUTOKENS or NUMBER or NUMBERS or notation group');
export const linkAttributeDeclaredValue = new MessageType0(MessageType.Severity.error, null, -1, 'declared value for link attribute cannot be ID or IDREF or IDREFS');
export const simpleLinkFixedAttribute = new MessageType0(MessageType.Severity.error, null, -1, 'in simple link declaration, attribute must have default value #FIXED');
export const duplicateAttlistElement = new MessageType1(MessageType.Severity.error, null, -1, 'element %1 already has an attribute definition list');
export const simpleLinkAttlistElement = new MessageType1(MessageType.Severity.error, null, -1, 'element %1 in ATTLIST declaration must be same as in DOCTYPE declaration');
export const duplicateAttlistNotation = new MessageType1(MessageType.Severity.error, null, -1, 'notation %1 already has an attribute definition list');
export const missingAfdrDecl = new MessageType0(MessageType.Severity.warning, null, -1, 'no AFDR declaration');
export const specifiedAttributeRedeclared = new MessageType1(MessageType.Severity.error, null, -1, 'attribute %1 has already been specified');
export const attlistGroupDecl = new MessageType0(MessageType.Severity.warning, null, -1, 'ATTLIST declaration with name group');
export const dataAttributes = new MessageType0(MessageType.Severity.warning, null, -1, 'data attributes');
export const nameDeclaredValue = new MessageType0(MessageType.Severity.warning, null, -1, 'NAME declared value');
export const numberDeclaredValue = new MessageType0(MessageType.Severity.warning, null, -1, 'NUMBER declared value');
export const nutokenDeclaredValue = new MessageType0(MessageType.Severity.warning, null, -1, 'NUTOKEN declared value');
export const dataAttributeDefaultValue = new MessageType0(MessageType.Severity.error, null, -1, 'data attribute cannot have default value #CURRENT or #CONREF');
export const linkAttributeDefaultValue = new MessageType0(MessageType.Severity.error, null, -1, 'link attribute cannot have default value #CURRENT or #CONREF');
export const currentAttribute = new MessageType0(MessageType.Severity.warning, null, -1, '#CURRENT attribute');
export const conrefAttribute = new MessageType0(MessageType.Severity.warning, null, -1, '#CONREF attribute');
export const notationConref = new MessageType0(MessageType.Severity.error, null, -1, 'NOTATION attribute cannot have default value #CONREF');
export const idDeclaredValue = new MessageType0(MessageType.Severity.error, null, -1, 'ID attribute cannot have default value');
export const attcnt = new MessageType2(MessageType.Severity.error, null, -1, 'number of tokens in attribute definition list %1 exceeds ATTCNT (%2)');

// Shortref declaration messages
export const shortrefOnlyInBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'SHORTREF declaration not allowed in DTD subset that is not base');
export const duplicateShortrefDeclaration = new MessageType1L(MessageType.Severity.error, null, -1, 'short reference map %1 already defined');
export const unknownShortrefDelim = new MessageType1(MessageType.Severity.error, null, -1, '%1 is not a short reference delimiter');
export const delimDuplicateMap = new MessageType1(MessageType.Severity.error, null, -1, 'short reference delimiter %1 already mapped in this declaration');

// Usemap declaration messages
export const usemapOnlyInBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'USEMAP declaration not allowed in DTD subset that is not base');
export const undefinedShortrefMapInstance = new MessageType1(MessageType.Severity.error, null, -1, 'short reference map %1 not defined');
export const usemapAssociatedElementTypeInstance = new MessageType0(MessageType.Severity.error, null, -1, 'USEMAP declaration in document instance cannot have associated element type');
export const usemapAssociatedElementTypeDtd = new MessageType0(MessageType.Severity.error, null, -1, 'USEMAP declaration in DTD subset must have associated element type');

// AFDR declaration messages
export const afdrVersion = new MessageType1(MessageType.Severity.error, null, -1, 'minimum data of AFDR declaration must be "ISO/IEC 10744:1997" not %1');

// Link declaration messages
export const idlinkDeclSimple = new MessageType0(MessageType.Severity.error, null, -1, 'ID link set declaration not allowed in simple link declaration subset');
export const linkDeclSimple = new MessageType0(MessageType.Severity.error, null, -1, 'link set declaration not allowed in simple link declaration subset');
export const duplicateIdLinkSet = new MessageType0(MessageType.Severity.error, null, -1, 'only one ID link set declaration allowed in an LPD subset');
export const duplicateLinkSet = new MessageType1(MessageType.Severity.error, null, -1, 'link set %1 already defined');
export const assocElementDifferentAtts = new MessageType0(MessageType.Severity.error, null, -1, 'element types have different link attribute definitions');
export const multipleIdLinkRuleAttribute = new MessageType1(MessageType.Severity.error, null, -1, 'multiple link rules for ID %1 but not all have link attribute specifications');
export const multipleLinkRuleAttribute = new MessageType1(MessageType.Severity.error, null, -1, 'multiple link rules for element type %1 but not all have link attribute specifications');
export const duplicateImpliedResult = new MessageType1(MessageType.Severity.error, null, -1, '#IMPLIED already linked to result element type %1');
export const emptyResultAttributeSpec = new MessageType0(MessageType.Severity.error, null, -1, 'empty result attribute specification');
export const noSuchResultElement = new MessageType1(MessageType.Severity.error, null, -1, 'no result element type %1');

// Uselink declaration messages
export const uselinkBadLinkType = new MessageType1(MessageType.Severity.error, null, -1, 'no link type %1');
export const uselinkSimpleLpd = new MessageType1(MessageType.Severity.error, null, -1, 'link set use declaration for simple link process');
export const uselinkBadLinkSet = new MessageType2(MessageType.Severity.error, null, -1, 'link type %1 does not have a link set %2');

// DOCTYPE declaration messages
export const multipleDtds = new MessageType0(MessageType.Severity.error, null, -1, 'DTDs other than base allowed only if CONCUR YES or EXPLICIT YES');
export const dtdAfterLpd = new MessageType0(MessageType.Severity.error, null, -1, 'DTD not allowed after an LPD');
export const impliedDoctypeConcurLink = new MessageType0(MessageType.Severity.error, null, -1, 'can\'t use #IMPLICIT doctype unless CONCUR NO and LINK EXPLICIT NO');
export const sorryImpliedDoctype = new MessageType0(MessageType.Severity.error, null, -1, 'Sorry, #IMPLIED doctypes not implemented');
export const duplicateDtd = new MessageType1(MessageType.Severity.error, null, -1, 'document type %1 already defined');
export const noDtdSubset = new MessageType0(MessageType.Severity.error, null, -1, 'no internal or external document type declaration subset; will parse without validation');
export const noDtd = new MessageType0(MessageType.Severity.error, null, -1, 'no document type declaration; will parse without validation');
export const omittedProlog = new MessageType0(MessageType.Severity.error, null, -1, 'prolog can\'t be omitted unless CONCUR NO and LINK EXPLICIT NO and either IMPLYDEF ELEMENT YES or IMPLYDEF DOCTYPE YES');
export const implyingDtd = new MessageType1(MessageType.Severity.error, null, -1, 'no document type declaration; implying %1');

// LINKTYPE declaration messages
export const lpdBeforeBaseDtd = new MessageType0(MessageType.Severity.error, null, -1, 'LPD not allowed before first DTD');
export const duplicateDtdLpd = new MessageType1(MessageType.Severity.error, null, -1, 'both document type and link type %1');
export const duplicateLpd = new MessageType1(MessageType.Severity.error, null, -1, 'link type %1 already defined');
export const noSuchDtd = new MessageType1(MessageType.Severity.error, null, -1, 'no DTD %1 declared');
export const simpleLinkFeature = new MessageType0(MessageType.Severity.error, null, -1, 'simple link requires SIMPLE YES');
export const implicitLinkFeature = new MessageType0(MessageType.Severity.error, null, -1, 'implicit link requires IMPLICIT YES');
export const explicitLinkFeature = new MessageType0(MessageType.Severity.error, null, -1, 'explicit link requires EXPLICIT YES');
export const simpleLinkResultNotImplied = new MessageType0(MessageType.Severity.error, null, -1, 'result document type in simple link specification must be implied');
export const simpleLinkCount = new MessageType1(MessageType.Severity.error, null, -1, 'number of active simple link processes exceeds quantity specified for SIMPLE parameter in SGML declaration (%1)');
export const oneImplicitLink = new MessageType0(MessageType.Severity.error, null, -1, 'only one implicit link process can be active');
export const duplicateExplicitChain = new MessageType0(MessageType.Severity.error, null, -1, 'only one chain of explicit link processes can be active');
export const explicitNoRequiresSourceTypeBase = new MessageType1(MessageType.Severity.error, null, -1, 'source document type name for link type %1 must be base document type since EXPLICIT NO');
export const explicit1RequiresSourceTypeBase = new MessageType1(MessageType.Severity.error, null, -1, 'source document type name for link type %1 must be base document type since EXPLICIT YES 1');
export const sorryLink = new MessageType1(MessageType.Severity.warning, null, -1, 'sorry, link type %1 not activated: only one implicit or explicit link process can be active (with base document type as source document type)');
export const noLpdSubset = new MessageType1(MessageType.Severity.warning, null, -1, 'LPD %1 has neither internal nor external subset');
